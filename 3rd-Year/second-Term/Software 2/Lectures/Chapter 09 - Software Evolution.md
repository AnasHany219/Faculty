### 🔄 **Software Evolution**

📈 **Continuous Development**:
- Software evolution is ongoing throughout its lifetime.
- Business changes and user expectations drive new requirements.
- Maintenance, error correction, and performance improvements are common.

💰 **Investment and Cost**:
- Organizations heavily invest in software and depend on it for business.
- Most companies spend more on maintaining existing systems than on new development.
- Evolution costs are a significant part of the IT budget.

🔀 **Triggers for Evolution**:
- Changes in business requirements, software defects, and environmental changes.
- 'Brownfield software development' describes dependency on multiple systems.

🌐 **Interconnected Evolution**:
- System evolution is influenced by changes in its operational environment.
- Understanding the impact of proposed changes on other systems is crucial.

📆 **Longevity and Releases**:
- Useful software systems have long lifetimes.
- Releases and updates are created regularly to adapt to changing requirements.

🌀 **Spiral Process**:
- Software engineering is a spiral process with ongoing requirements, design, implementation, and testing.
- Evolution may start even before the deployment of the current version.

🏭 **Organizational Responsibility**:
- Packaged software products vs. custom software development approaches.
- Seamless transition from development to evolution is essential for efficient maintenance.

🛠️ **Software Evolution Life Cycle**:
- Evolution vs. servicing phases with significant vs. small changes.
- Transition from evolution to servicing occurs when significant changes become less cost-effective.

🔄 **Change Proposals and Evolution Processes**:
- Change proposals drive system evolution.
- Change identification, analysis, and implementation are iterative processes.

📝 **Change Implementation**:
- Iterative process involving system understanding, redesign, implementation, and testing.
- Modifications to system specification, design, and implementation reflect changes.

🚨 **Emergency Changes**:
- Urgent changes due to serious faults, environmental changes, or business shifts.
- Emergency fixes may lead to inconsistency and accelerate software aging.

🔄 **Agile Methods for Evolution**:
- Seamless transition from agile development to post-delivery evolution.
- Challenges may arise in handover between development and evolution teams.

💡 **Experience with Agile Maintenance**:
- Extreme Programming used successfully for maintaining large systems after reengineering.
---
### 🔄 **Program Evolution Dynamics**

🔍 **Study of System Change**:
- Lehman and Belady conducted empirical studies to understand software evolution.
- They proposed 'Lehman’s laws' concerning system change dynamics.

📜 **Lehman’s Laws**:
1. **Continuing Change**: System maintenance is inevitable as requirements evolve.
2. **Increasing Complexity**: System structure degrades over time without preventative maintenance.
3. **Large Program Evolution**: System attributes remain relatively constant across releases.
4. **Organizational Stability**: Rate of development is constant over the system's lifetime.
5. **Conservation of Familiarity**: Incremental changes in each release remain constant.
6. **Continuing Growth**: Functionality must increase to maintain user satisfaction.
7. **Declining Quality**: Quality declines without modifications reflecting operational changes.
8. **Feedback System**: Evolution processes incorporate feedback loops for significant improvement.

🔄 **Third Law Dynamics**:
- Large systems have established dynamics early in development.
- Structural degradation and organizational decision-making influence system change.

🏢 **Organizational Factors**:
- Bureaucratic structures influence change budgeting and decision-making.
- Speed of decision-making governs the rate of system change.

📉 **Fourth Law - Saturated State**:
- Changes to resources or staffing have little effect on long-term system evolution.
- Communication overheads dominate large software development teams.

🛠️ **Fifth Law - Change Increments**:
- Adding new functionality introduces new system faults.
- Large functionality increments require subsequent releases for fault repair.

💡 **Implications**:
- Users become increasingly unhappy without maintenance and new functionality.
- Business considerations may sometimes require ignoring Lehman’s laws, leading to multiple major system changes in a single release.
---
### 🛠️ **Software Maintenance**

🔧 **Definition**: Software maintenance involves changing a system after delivery, addressing coding errors, design flaws, and accommodating new requirements.

📝 **Types of Maintenance**:
1. **Fault Repairs**: Correcting coding, design, or requirement errors, with costs varying based on the type of error.
2. **Environmental Adaptation**: Modifying the system to cope with changes in its environment, like hardware or operating system updates.
3. **Functionality Addition**: Incorporating new functionality to meet evolving organizational or business needs.

🔄 **Interconnected Maintenance Types**:
- Adaptations to the environment may involve adding new functionality.
- User actions may expose faults, prompting changes to accommodate user behavior.

📊 **Maintenance Cost Distribution**:
- Typically, maintenance consumes a higher portion of IT budgets than new development.
- Majority of maintenance budgets are allocated to implementing new requirements rather than fixing bugs.

💡 **Cost-Effective Measures**:
- Investing in designing and implementing a system for maintainability during development reduces future maintenance costs.
- Good software engineering practices like precise specification and configuration management contribute to cost reduction.

🔄 **Reengineering and Refactoring**:
- **Reengineering**: Enhances legacy systems by improving their structure and understandability without changing functionality.
- **Refactoring**: Continuous improvement process during development to maintain or improve program structure, reducing future maintenance costs.

📉 **Predictive Maintenance**:
- Utilizes metrics like number of change requests, impact analysis time, and implementation time to predict maintenance costs.
- Helps managers estimate maintenance effort and costs.

⚙️ **Software Reengineering Process**:
1. **Source Code Translation**: Converting legacy code to a more modern language.
2. **Reverse Engineering**: Analyzing and documenting existing system organization and functionality.
3. **Program Structure Improvement**: Modifying control structures for readability.
4. **Program Modularization**: Grouping related components and removing redundancy.
5. **Data Reengineering**: Adapting data structures to reflect program changes.

🔄 **Refactoring for Preventative Maintenance**:
- **Definition**: Modifying programs to improve structure, reduce complexity, or enhance understandability without adding functionality.
- **Benefits**: Reduces future maintenance difficulties and costs.
- **Techniques**: Address 'bad smells' like duplicate code or long methods through refactoring transformations.
---
### 🌟 **Legacy System Management**

🔄 **Integration and Evolution**:
- New systems use modern processes like incremental development and CBSE.
- Companies realize software development is a life-cycle process.
- Legacy systems need adaptation to evolving e-business practices.

📊 **Strategic Options**:
1. **Scrap completely:** If the system no longer contributes effectively.
2. **Leave unchanged:** If still required and stable with few change requests.
3. **Reengineer:** Improve maintainability when quality has degraded.
4. **Replace:** When old system cannot continue, or new systems offer cost-effective solutions.

💼 **Assessment**:
- Business and technical perspectives are crucial.
- Consider business value and system quality for decision-making.
- Assess each legacy system individually for quality and business value.

🎯 **Business Value Assessment**:
- Evaluate usage, supported processes, dependability, and system outputs.
- Systems with high business value should be retained or improved.

🛠️ **Technical Perspective**:
- Assess application system and environment.
- Consider hardware, support software, maintenance costs, and interoperability.
- Evaluate system documentation, data model, and performance.

📈 **Objective Assessment**:
- Ideally, use objective measures for decision-making.
- Political or organizational factors may influence decisions, especially in mergers.

🔍 **Environmental Assessment Factors**:
- Supplier stability, failure rate, age, performance, support requirements, and maintenance costs.

📝 **Technical Quality Assessment**:
- Consider system change requests, user interfaces, data volume, and other factors.

🔍 **Assessment Questions**:
- Supplier stability, failure rate, age, performance, support requirements, maintenance costs, interoperability, understandability, documentation, data, programming language, configuration management, test data, personnel skills.
---
###  🔑 Key Points 🔑

1. **Integrated Process**: Software development and evolution are integrated and iterative, often represented by a spiral model.
2. **Maintenance Costs**: For custom systems, maintenance costs usually surpass development costs.
3. **Software Evolution Process**: Driven by change requests, the process includes change impact analysis, release planning, and implementation.
4. **Lehman's Laws**: Derived from long-term studies, Lehman's laws describe insights like the continuous nature of change.
5. **Types of Maintenance**: Three types include bug fixing, environmental adaptation, and implementing new requirements.
6. **Software Reengineering**: Involves restructuring and redocumenting software to enhance understandability and changeability.
7. **Refactoring as Preventative Maintenance**: Making small changes to preserve functionality helps prevent degradation over time.
8. **Assessment for Legacy Systems**: Assessing business value, application quality, and environment guides decisions on replacement, transformation, or maintenance.
---
### 📝 Exercises 📝

**9.1.** Why must a software system in a real-world environment change over time?
- **Answer:** A software system must adapt to evolving needs and environments to remain useful.

**9.2.** What's the rationale behind Lehman’s laws? When might they not apply?
- **Answer:** Lehman’s laws describe patterns of system evolution. They might not apply if a system's environment remains static.

**9.3.** What activities are involved in change impact analysis?
- **Answer:** Change impact analysis includes assessing the effects of proposed changes on various system aspects, such as functionality, performance, and interfaces.

**9.4.** How might a software project manager analyze maintainability factors and metrics?
- **Answer:** The manager could establish a program to track maintenance activities and identify key metrics such as bug fix time and frequency of change requests.

**9.5.** Describe the three main types of software maintenance and why they can be challenging to distinguish.
- **Answer:** The main types are bug fixing, environmental adaptation, and functionality addition. They can blur together because changes often overlap in nature.

**9.6.** What factors influence the costs of system reengineering?
- **Answer:** Complexity of the system, extent of required changes, and availability of automated tools affect reengineering costs.

**9.7.** When might an organization decide to retire a high-quality, valuable system?
- **Answer:** If the support software becomes obsolete or if the system no longer aligns with organizational goals.

**9.8.** What are the strategic options for legacy system evolution, and when is system replacement preferable?
- **Answer:** Options include maintenance, reengineering, or replacement. Replacement is preferred when maintenance becomes impractical or the system no longer meets business needs.

**9.9.** Why might issues with support software necessitate replacing legacy systems?
- **Answer:** Incompatibility or end-of-life support for support software can make it impossible to maintain the legacy system.

**9.10.** Are software engineers ethically obliged to produce maintainable code?
- **Answer:** Yes, they have a professional responsibility to ensure that code can be maintained, as this contributes to the longevity and reliability of software systems.
---
